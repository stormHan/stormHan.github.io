<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Fighting Life!" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="拿梦想做赌注，我怎么舍得输？">
<meta property="og:type" content="website">
<meta property="og:title" content="Han's Blog Cell">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Han's Blog Cell">
<meta property="og:description" content="拿梦想做赌注，我怎么舍得输？">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Han's Blog Cell">
<meta name="twitter:description" content="拿梦想做赌注，我怎么舍得输？">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Han's Blog Cell </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Han's Blog Cell</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hi, My world!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计---模板/" itemprop="url">
                  C++程序设计---模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:37:26+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>. 1，文件操作<br>. 2，函数模板</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="1，数据的层次"><a href="#1，数据的层次" class="headerlink" title="1，数据的层次"></a>1，数据的层次</h3><p>位      bit<br>字节    byte<br>域/记录 如一个结构体等。<br>将所有记录<strong>顺序</strong>写入一个文件-&gt;顺序文件</p>
<p>C++标准库： ifstream ofstream fstream</p>
<h3 id="3，文件的读写指针"><a href="#3，文件的读写指针" class="headerlink" title="3，文件的读写指针"></a>3，文件的读写指针</h3><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>泛型程序设计<br>Generic Programming<br>算法实现时不指定具体要操作的数据的类型。<br><strong>泛型</strong>—算法实现一遍-&gt;适用于多种数据结构。<br>优势： 减少重复代码的编写。<br>大量编写模板，使用模板的程序设计</p>
<blockquote>
<p>. 函数模板<br>. 类模板</p>
</blockquote>
<p>函数模板<br>template <class 类型参数1，="" class类型参数2,="" ..=""><br>返回值类型 模板名（形参表）<br>{<br>    函数体<br>}</class></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计--多态和虚函数/" itemprop="url">
                  C++程序设计--多态和虚函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:52+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目的： 提高程序的可扩展性，减少增加代码时的工作量。<br>代价： 每一个有虚函数的对象都会增加四个字节的空间来存放虚函数表（空间开销）。虚函数在查虚函数表的时候会有（时间）开销。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在类的定义中，前面有<strong>virtual</strong>关键字的成员函数就是虚函数。<br>class base{<br>    <strong>virtual</strong> int get();<br>    }<br>int base::get(){};<br>virtual关键字只用在类定义里的函数声明中，写函数体时不用。<br>构造函数和静态成员函数不能是虚函数。<br>虚函数支持多态。</p>
<h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><h3 id="一，"><a href="#一，" class="headerlink" title="一，"></a>一，</h3><p>派生类的指针可以赋给基类指针。<br>通过基类指针调用基类和派生类的同名虚函数时，<br>（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；<br>（2）若指针指向一个派生类的对象，那么被调用的是派生类的虚函数。<br>这种机制就叫做“多态”。</p>
<h3 id="二，"><a href="#二，" class="headerlink" title="二，"></a>二，</h3><p>派生类的多态可以赋给基类引用。<br>通过基类引用调用基类和派生类的同名虚函数时，<br>（1）若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。<br>这种机制也是“多态”。</p>
<p><strong>实际上，我们用一个基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常用的做法</strong>(例如 pshapes[100])</p>
<p>同时，在非构造函数和非析构函数的成员函数中调用虚函数，是多态！<br>而在构造函数和析构函数中调用虚函数，不是多态。这在编译时就可以确定了调用的函数是自己的类或基类中定义的函数，不会等到运行时才确定要调用哪个函数。</p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p>在运行时决定调用基类还是派生类，“动态联编”。<br>多态实现的关键—虚函数表。每一个有虚函数的类（或者有虚函数的类的派生类），都有一个虚函数表与其对应。该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的四个字节就是用来放虚函数表地址的。<br>so, 多态的调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。<br><img src="http://ww2.sinaimg.cn/mw690/a207cfd8gw1f4nwq0yglyj20ha0dkdh3.jpg" alt=""></p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>针对基类的指针删除派生类对象时 只调用基类的析构函数这种情况。<br>设计一种虚析构函数。<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8gw1f4nwq1wljej20jj0attaf.jpg" alt=""><br>类如果定义了额虚函数，则最好将析构函数也定义成虚函数。<br>当然，我们不允许构造函数是虚函数。</p>
<h2 id="纯虚函数和抽象类。"><a href="#纯虚函数和抽象类。" class="headerlink" title="纯虚函数和抽象类。"></a>纯虚函数和抽象类。</h2><p>纯虚函数： 没有函数体的虚函数。<br>抽象类 ： 包含纯虚函数的类。<br>1， 抽象类住能作为基类。<br>2， 不能创建抽象类的对象。<br>3， 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象<br><img src="http://ww4.sinaimg.cn/mw690/a207cfd8gw1f4nwq2oyqmj20na0dldij.jpg" alt=""></p>
<p>在抽象类中，<br>1，成员函数内可以调用纯虚函数/<br>2，在构造函数/析构函数内部不能调用纯虚函数。</p>
<p>如果一个类从抽象类派生而来<br>它实现了基类中所有的纯虚函数，才能成为非抽象类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计---继承和派生/" itemprop="url">
                  C++程序设计---继承和派生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:40+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继承： 在定义一个新的类B时，如果该类与某个已有的类A相似（<strong>指的是B拥有A的全部特点</strong>），那么就可以把A作为一个基类，而把B作为基类的一个派生类（也称为子类）。</p>
<h2 id="派生类："><a href="#派生类：" class="headerlink" title="派生类："></a>派生类：</h2><blockquote>
<p>派生类拥有基类的全部成员函数和成员变量，不论是private, protected还是public。<br>派生类可以对基类进行扩充，添加新的成员变量和成员函数。派生类的使用和基类无关。</p>
</blockquote>
<p>tip: 在派生类的成员函数中，不能访问继承自基类的private成员。</p>
<h3 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h3><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置位于派生类对象新增的成员变量之前。</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>派生类可以有和基类同名同参数表的函数，将会覆盖掉基类中的成员函数而不算是重复定义。比较常见的是，在派生类的覆盖函数中，先调用基类的该函数，再处理自己不同于基类中该函数的部分。</p>
<h2 id="继承关系和复合关系"><a href="#继承关系和复合关系" class="headerlink" title="继承关系和复合关系"></a>继承关系和复合关系</h2><p>继承： “<strong>是</strong>”关系。<br>基类A, B是基类A的派生类。<br>逻辑上要求：“一个B对象也是一个A对象”。</p>
<p>复合： “<strong>有</strong>”关系。<br>类C中“有”成员变量K, k是类D的对象，则C和D是复合关系。<br>一般逻辑上要求： “D对象是C对象的固有属性或者组成部分”。</p>
<p>tips:<br>1，在一个类中，如果有一个成员变量是其他类的指针，通常称为是“知道”关系。<br>2， 对于基类/派生类 同名成员，调用基类的public成员时得用 base::__ 来调用。</p>
<h2 id="访问范围说明符"><a href="#访问范围说明符" class="headerlink" title="访问范围说明符"></a>访问范围说明符</h2><p>基类的 private成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数</p>
<p>基类的 public成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数<br>    3，派生类成员函数<br>    4，派生类友员函数<br>    5，其它的函数(故用private和public并不能凸显派生类和其他类的区别，引入protected)<br>基类的 protected成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数<br>    3，派生类的成员函数可以访问<strong>当前对象</strong>的基类的保护成员</p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类对象 包含 基类对象。<br>执行派生类构造函数前，首先必须执行<strong>基类的构造函数</strong>。<br>如果派生类中还包含成员对象，也是用参数表的形式构造。<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f4koz7s1d7j20oh0dun0j.jpg" alt=""><br>具体形式：<br>构造函数名（形参表）：基类名（基类构造函数实参表），…,成员对象（实参表）,…<br>{<br>}</p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p>class base {};<br>class derived : <strong>public</strong> base {};<br>base b; derived d;<br>在加了public后，有以下几条赋值兼容规则。<br>1，派生类的对象可以赋值给基类对象。<br> b = d;（把d里面包含的base对象 赋值到b里去）<br>2，派生类对象可以初始化基类引用。<br> base&amp; br = d;<br>3， 派生类对象的地址可以赋值给基类的指针<br> base* pb = &d;</p>
<p> tips : 声明派生类时，只需要列出它直接基类，构造时也只考虑直接基类的参数表。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计--运算符重载/" itemprop="url">
                  C++程序设计--运算符重载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:30+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>1， 运算符重载<br>2， 赋值运算符的重载<br>3， 流插入运算符重载<br>4，自加/自减运算符的重载</p>
</blockquote>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>作用：对抽象数据类型也能够直接使用C++提供的运算符。<br>使得程序更简洁。<br>代码更容易理解。</p>
<p><strong>运算符重载的实质是函数重载</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">返回值类型 operator运算符 （形参表）</div><div class="line">&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">class Complex</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Complex(double r = 0.0, double i = 0.0);</div><div class="line">	</div><div class="line"></div><div class="line">	Complex operator+(const Complex c1);</div><div class="line">	Complex operator-(const Complex c1);</div><div class="line"></div><div class="line">	double real;</div><div class="line">	double imag;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Complex::Complex(double r, double i)</div><div class="line">&#123;</div><div class="line">	real = r;</div><div class="line">	imag = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Complex Complex::operator+(const Complex c1)</div><div class="line">&#123;</div><div class="line">	return Complex(real + c1.real, imag + c1.imag);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Complex Complex::operator-(const Complex c1)</div><div class="line">&#123;</div><div class="line">	return Complex(this-&gt;real - c1.real, this-&gt;imag - c1.imag);</div><div class="line">&#125;</div><div class="line">//普通类型的运算符重载</div><div class="line">Complex operator+ (const Complex c1, const Complex c2)</div><div class="line">&#123;</div><div class="line">	return Complex(c1.real + c2.real, c1.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运算符可以重载成普通函数，也能重载为成员函数。前者的参数个数就是对应操作符的目数，而成员函数则是目数减一。</p>
<h3 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h3><p>1，赋值运算符两边的类型可以不匹配。<br>如：将一个Int类型的变量赋值给一个Complex对象。<br>2，对一个自己写的类想要进行 = 赋值时，需要重载赋值运算符”=”<br>3，赋值运算符“=”只能重载为<strong>成员函数</strong><br><strong>一般来说，赋值运算符的重载的返回值是该对象本身的引用，来满足=的意义。</strong></p>
<h3 id="流插入运算符重载"><a href="#流插入运算符重载" class="headerlink" title="流插入运算符重载"></a>流插入运算符重载</h3><p>cout本身就是ostream的一个对象，而cout&lt;&lt;其实是在ostream类中对&lt;&lt;进行了重载。<br>我们如果想通过&lt;&lt; &gt;&gt;来实现自己对应的对象的输入和输出，则可以自己来重载这两个运算符。<br>一般定义为全局函数，因为iostream类C++已经写好了。<br>比如实现对复数类的输入输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, Complex&amp; c)</div><div class="line">&#123;</div><div class="line">	o &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">istream&amp; operator&gt;&gt;(istream&amp; i, Complex&amp; c)</div><div class="line">&#123;</div><div class="line">	//先读进string里面再分别剥离出real imag</div><div class="line">	return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自加-自减运算符的重载"><a href="#自加-自减运算符的重载" class="headerlink" title="自加/自减运算符的重载"></a>自加/自减运算符的重载</h3><p>前置和后置有区别，<br>前置是一元运算符，后置是二元运算符。多出来的一个参数具体是啥无意义，只是为了标记这是一个后置运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class CDemo</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	CDemo(int _n) :n(_n)&#123;&#125;;</div><div class="line"></div><div class="line">	CDemo operator++();</div><div class="line">	CDemo operator++(int);</div><div class="line"></div><div class="line">	//强制类型转化</div><div class="line">	operator int()&#123; return n; &#125;</div><div class="line">	</div><div class="line">	friend CDemo operator--(CDemo&amp;);</div><div class="line">	friend CDemo operator--(CDemo&amp;, int);</div><div class="line">private:</div><div class="line">	int n;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//前置</div><div class="line">CDemo CDemo::operator++()</div><div class="line">&#123;</div><div class="line">	n++;</div><div class="line">	return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CDemo operator--(CDemo&amp; d)</div><div class="line">&#123;</div><div class="line">	d.n--;</div><div class="line">	return d;</div><div class="line">&#125;</div><div class="line">//后置</div><div class="line">CDemo CDemo::operator++(int)</div><div class="line">&#123;</div><div class="line">	CDemo temp (*this);</div><div class="line">	n++;</div><div class="line">	return temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CDemo operator--(CDemo&amp; d, int)</div><div class="line">&#123;</div><div class="line">	CDemo t = d;</div><div class="line">	d.n--;</div><div class="line">	return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：上面的demo中int作为一个类型强制转换运算符被重载，Demo s; (int)s等效于s.int()。<br>类型强制转换运算符被重载时，不能写返回值类型，实际上其返回值就是类型转换所代表的类型。</p>
<p>Tips:<br>1，C++不允许定义新的运算符。<br>2，重载后的运算符应该符合日常习惯。<br>3，重载运算符不能改变运算符的优先级。<br>4，以下运算符不能被重载。”.” “*” “::” “?”,sizeof<br>5，重载运算符(), [], -&gt;或者赋值运算符时，只能被声明为类的成员函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++ 程序设计思想（I）/" itemprop="url">
                  C++ 程序设计思想基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:21+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  最近发现了coursera上比较好的几门课，是来自北京大学的程序设计与算法系列课程，于是想重新回顾一下C++这门及其注重效率的语言的一些特性。同时对自己的相关知识查漏补缺，以及做一些记录。<a href="http://jianshu.io" target="_blank" rel="external">course </a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>1， 内联成员函数和缺省参数的函数<br>2， 构造函数</p>
</blockquote>
<h3 id="内联成员函数和缺省参数的函数"><a href="#内联成员函数和缺省参数的函数" class="headerlink" title="内联成员函数和缺省参数的函数"></a>内联成员函数和缺省参数的函数</h3><p>之前我们知道，内联函数存在的目的是，当一些比较简单又调用次数特别多的函数的时候，为了减少调用函数入栈时候的额外开销，我们设置一种内联函数，编译器在碰到内联函数的时候，直接把函数的代码粘过来运行。这是C++这样一种追求极致效率的语言的一种特殊机制。<br>那么内联成员函数的声明方法：<br>1， inline + 成员函数<br>2，整个函数体出现在类定义内部，也就是说当你把函数体写在类定义里面时，这些默认为内联函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class B&#123;</div><div class="line">    inline void func1();</div><div class="line">    void func2()&#123;&#125;;</div><div class="line">    void init(int x = 1, int y = 2);</div><div class="line">    private: int x, int y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的func1()和func2()都是内联函数。</p>
<p>而缺省参数的路由是在函数的参数列表中已经给一些参数一个默认值，如之上的init()函数。那么当你调用函数的参数不够时，剩下的（靠近右边的）用默认参数。那么这种设定有什么用呢？是当你在开发较为简单的功能的时候，考虑到程序的可扩展性，即之后可能还会将某些现在是固定值的变量变成一个可控变量。则可以用到这种技术。</p>
<p>用重载函数和缺省参数的函数时，一定要避免函数的二义性。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>1， 一个类可以有多个构造函数。<br>2， 当定义了构造函数，则编译器不生成默认的无参数的构造函数（肯定会有一个构造函数）<br>3， 不分配内存，是在new一个对象时对这个对象进行作用。</p>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>只有一个参数，即对同类对象的引用。形如X::X( X&amp; )或者X::X(const X&amp; )。<br>如果没有定义复制构造函数，那么编译器生成默认的复制构造函数。（所以当我们不写构造函数的时候，编译器会至少为我们写两个构造函数）而当你自己写了一个复制构造函数的时候，编译器就不会帮你生成复制构造函数了。</p>
<p>注意：<br>1，当初始化的时候调用 A a1 = a2;这一句是初始化语句。a1 = a2这一句是赋值语句，体会这两者的不同。<br>2， 当一个函数中有一个参数是类A的对象，那么当该函数被调用时，类A的复制构造函数将会被调用（对形参）。<br><strong>这个时候如果你自己写了这个类的复制构造函数，那么可能这个时候实参和形参没有经历过复制工作。</strong><br>3，如果函数的返回值是类A的对象时，则函数返回式，A的复制构造函数被调用。</p>
<p>在什么时候要自己写复制构造函数。（to be continued..）<br>引用作为参数时是没有生成对象的，也即不会有复制的过程，也不会调用复制构造函数。</p>
<h3 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h3><p>目的：实现类型的自动转换。<br>特点：只有一个参数，不是复制构造函数。<br>编译器自动调用-&gt;转换构造函数-&gt;建立一个临时对象。<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f4bec8lspsj20od0djwi0.jpg" alt=""></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>名字与类名相同。<br>前面加上~<br>没有返回值，没有参数，只有一个。</p>
<p>在对象消亡时自动被调用。用于做“善后”工作，释放内存等。</p>
<p>注意：对象数组的生命期结束时，每个元素的析构函数都会被调用。而对象的生命作用域是离他最近的一对花括号。当跳出作用域时，就会调用析构函数。当然，<strong>static静态对象和全局对象则在最后依次被消亡。</strong></p>
<h3 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h3><p>1，静态成员对象和普通成员对象的本质区别是，普通成员变量每个对象有格子的一份，而静态成员变量一共就一份，为所有对象共享。这也是sizeof不会算static变量的原因。<br>2，普通成员函数必须作用于某个对象，而静态成员函数并不具体作用于某个对象。<br>3，因此静态成员不需要通过对象就能访问。</p>
<p>如果访问静态成员？<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f4bec7fzfxj20jr0dsgo8.jpg" alt=""><br>不管怎么访问，但它都不属于某个特定的对象。</p>
<p><strong>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在；</strong><br><strong>静态成员函数本质上是全局函数；</strong><br><strong>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。（换句话说是对全局变量分类）</strong></p>
<p>注意：<br>1，在C++中，必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则编译能通过链接不能通过。<br>2，在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</p>
<h3 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h3><p>成员对象：一个类的成员变量是另一个类的对象。<br>那么包含成员对象的类叫做<strong>封闭类（Enclosing）</strong>.<br>封闭类必须要自己定义构造函数，否则就会编译报错。所以要通过<strong>初始化列表</strong>来实现。</p>
<p><strong>初始化列表</strong><br>类名::构造函数（参数表）:成员变量1(参数表)，成员变量2(参数表),…<br>{<br>}<br>而成员对象初始化列表中的参数.1可以是任意复杂的表达式.2函数/变量等。</p>
<p>当封闭类对象生成时，先执行所有成员对象的构造函数，再执行封闭类的构造函数。（顺序和成员对象在类中的说明顺序一致，和初始化列表无关。）<br>当封闭类对象消亡时，先执行封闭类的析构函数，再执行所有成员对象的析构函数。<br><strong>析构函数顺序和构造函数的调用顺序相反</strong></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>作用：指向成员函数所作用的对象。是一种特殊的指针，相当于指向一个对象入口的指针。<br>注意，在静态成员函数中是不能使用this指针的。</p>
<h3 id="常量对象，常量成员函数"><a href="#常量对象，常量成员函数" class="headerlink" title="常量对象，常量成员函数"></a>常量对象，常量成员函数</h3><p>如果不希望某个对象的值被被改变，则定义该对象的时候可以再前面加<strong>const</strong>关键字。<br>而常量成员函数在执行期间不应该修改其所作用的对象。因此常量成员函数不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。</p>
<p>注意：如果两个名字一样的函数一个定义了const一个没有定义，那么算是重载而不是重复定义。分别使用在const对象和非const对象上。<br>在引用作为参数的是很常用的，而在有些情况下，为了确保对象不会被改变可以使用常引用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/enumeration/" itemprop="url">
                  枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:05+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>枚举，基于已有的知识进行答案猜测的一种问题求解策略。</strong><br>从可能的集合中一一列举各元素，根据已经知道的知识，给一个猜测的答案。</p>
<p>Ex.以找到比N小的最大素数为例</p>
<p><strong>枚举算法</strong></p>
<blockquote>
<p>对问题可能解集的每一项根据问题给定的检验条件判定哪些是成立的，使条件成立的即是问题的解。</p>
</blockquote>
<p><strong>枚举过程</strong></p>
<blockquote>
<p>1, 判断猜测的答案是否正确。（例如，2是小于N的最大素数吗）<br>2, 进行新的猜测：注意要保证，（1）猜测的结果必须是前面的猜测中没有出现过的。（每次猜测的素数要比之前的要大）（2）猜测的过程中要尽早的排除错误答案。（除2之外，只有奇数才可能是素数。）</p>
</blockquote>
<p>所以要考虑到三个关键问题。</p>
<blockquote>
<p>1， 给出解空间，建立简洁的数学模型。<br>2， 减少搜索的空间。 利用知识缩小模型中各个变量的范围。<br>3， 采用合适的搜索顺序。</p>
</blockquote>
<p>先附上之前问题的解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//找到小于N的最大素数</div><div class="line">//用这种枚举的方法，要比去判断n-1, n-2...是否是质数要快。</div><div class="line">int findNum(const int N)</div><div class="line">&#123;</div><div class="line">	int ret;</div><div class="line"></div><div class="line">	std::vector&lt;int&gt; prim;</div><div class="line">	prim.push_back(2);</div><div class="line">	bool flag = true; //标识当前的数是否是质数</div><div class="line">	for (int i = 3; i &lt; N; i = i + 2/* 排除偶数*/)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt; prim.size() - 1; ++j)</div><div class="line">		&#123;</div><div class="line">			if (i % prim[j] == 0)</div><div class="line">			&#123;</div><div class="line">				flag = false;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (flag) prim.push_back(i);//如果当前i是质数，把它Push到质数数组里</div><div class="line"></div><div class="line">		flag = true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return prim[prim.size() - 1];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例一-熄灯问题"><a href="#例一-熄灯问题" class="headerlink" title="例一 熄灯问题"></a>例一 熄灯问题</h2><p>问题描述</p>
<blockquote>
<pre><code>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行，每个按钮上有一盏灯。当你按下一个按钮后，该按钮以及其周围上下左右四盏灯都会改变，亮--&gt;暗或者暗--&gt;亮。
要求对矩阵中的每盏灯设置一个初始状态，请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。
</code></pre><p><img src="http://ww1.sinaimg.cn/mw690/a207cfd8gw1f495k5t33ij20qo0exwit.jpg" alt=""></p>
</blockquote>
<p><img src="http://ww2.sinaimg.cn/mw690/a207cfd8gw1f495k7la92j20i20etn02.jpg" alt=""></p>
<p>ji<br>如果穷举所有的状态，即为2^(5<em>6)种，肯定是不现实的。<br><em>*那么此时穷举的技巧是，如果存在某个局部，一旦这个局部的状态被确定，那么剩余其他部分的状态只能是确定的一种，或者不多的n种，那么就只需要枚举这个局部的状态就可以。</em></em><br>本题是有这样的“局部”的，当第一行的开关状态确定后，如果要熄灭第一行的所有灯，只能依靠第二行在第一行亮灯的对应位置下Press,故在第一行状态后，第二行的状态实际上已经确定好了；依次类推，第三行第四行…所有有一个思路是枚举第一行的所有的状态，然后判断第五行是否恰好都熄灭。以下是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">//-------------------------------------------------</div><div class="line">//**熄灯问题**</div><div class="line">//枚举第一行的所有情况 2^6 = 64种。</div><div class="line">//对于每一种情况，下面的1-4行结果唯一，最后判断第五行是否正好都别熄灭，若是，则得到正确解。</div><div class="line"></div><div class="line">int press[6][8], puzzle[6][8];</div><div class="line"></div><div class="line">bool guess()</div><div class="line">&#123;</div><div class="line">	for (int i = 1; i &lt; 7; ++i)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt; 5; ++j)</div><div class="line">		&#123;</div><div class="line">			//根据Press第一行和puzzle数组，计算press其它行的值</div><div class="line">			press[i + 1][j] = (puzzle[i][j] + press[i - 1][j] + press[i][j] + press[i][j + 1] + press[i][j - 1]) % 2;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for (int i = 1; i &lt; 7; ++i)</div><div class="line">	&#123;</div><div class="line">		//判断所计算的press数组能否熄灭第五行的所有灯</div><div class="line">		if ((puzzle[5][i] + press[5][i] + press[5][i - 1] + press[5][i + 1]) % 2 == 1)</div><div class="line">			return false;</div><div class="line">	&#125;</div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void enumerate()</div><div class="line">&#123;</div><div class="line"></div><div class="line"></div><div class="line">	int c;</div><div class="line">	for (c = 1; c &lt; 7; ++c)</div><div class="line">	&#123;</div><div class="line">		press[1][c] = 0;</div><div class="line">	&#125;</div><div class="line">	while (!guess())</div><div class="line">	&#123;</div><div class="line">		//对press第一行的元素的各种取值进行枚举，依次考虑</div><div class="line">		c = 1;</div><div class="line">		press[1][c]++;</div><div class="line">		//累加进位</div><div class="line">		while (press[1][c] &gt; 1)</div><div class="line">		&#123;</div><div class="line">			press[1][c] = 0;</div><div class="line">			c++;</div><div class="line">			press[1][c] += 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line"></div><div class="line">	int cases, i, r, c;</div><div class="line">	scanf(&quot;%d&quot;, &amp;cases); </div><div class="line"></div><div class="line">	//将扩大的矩阵的边缘用0填充</div><div class="line">	for (r = 0; r &lt; 6; r++)</div><div class="line">	&#123;</div><div class="line">		press[r][0] = 0;</div><div class="line">		press[r][7] = 0;</div><div class="line">	&#125;</div><div class="line">	for (c = 0; c &lt; 8; c++)</div><div class="line">	&#123;</div><div class="line">		press[0][c] = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (i = 0; i &lt; cases; ++i)</div><div class="line">	&#123;</div><div class="line">		for (r = 1; r &lt; 6; ++r)</div><div class="line">		&#123;</div><div class="line">			for (c = 1; c &lt; 7; ++c)</div><div class="line">			&#123;</div><div class="line">				scanf(&quot;%d&quot;, &amp;puzzle[r][c]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		enumerate();</div><div class="line">		</div><div class="line">		printf(&quot;PUZZLE# %d\n&quot;, i + 1);</div><div class="line">		for (r = 1; r &lt; 6; ++r)</div><div class="line">		&#123;</div><div class="line">			for (c = 1; c &lt; 7; ++c)</div><div class="line">			&#123;</div><div class="line">				printf(&quot;%d &quot;, press[r][c]);</div><div class="line">			&#125;</div><div class="line">			printf(&quot;\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="讨厌的青蛙"><a href="#讨厌的青蛙" class="headerlink" title="讨厌的青蛙"></a>讨厌的青蛙</h2><p>问题描述<br>    有一种青蛙，会跳跃稻田，从而踩踏稻子。青蛙总是沿着一条直线跳跃稻田，并且每次跳跃的距离都相同。（可竖直也可倾斜）。来看看标准输入输出。<br>    <img src="http://ww4.sinaimg.cn/mw690/a207cfd8jw1f49yg2oa21j20nu0fe0z3.jpg" alt=""><br>    <img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f49yg35ihqj20p30fodkg.jpg" alt=""><br>    <img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f49yg3so7aj20oq0fqq8v.jpg" alt=""><br>    <img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f49yg4epb6j20ol0fpdiu.jpg" alt=""></p>
<p>那么，我们枚举的是什么？肯定不能枚举所有可能出现的情况。<br>我们知道，两点确定一条直线，所以基本思路就是枚举第一个点和第二个点。<br>先直接粘贴代码，注释中有比较详细的思路。总结在之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"></div><div class="line">//-------------------------------------------------</div><div class="line">//**讨厌的青蛙**</div><div class="line">//定义了一个结构体用于描述踩踏水稻的横纵坐标</div><div class="line">struct Plant</div><div class="line">&#123;</div><div class="line">	int x;</div><div class="line">	int y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Plant plants[5000];</div><div class="line">int r, c, n;</div><div class="line">//申请一个动态的空间来存放稻田是否被踩踏</div><div class="line">int **field;</div><div class="line"></div><div class="line">int searchPath(int dx, int dy, Plant p)</div><div class="line">&#123;</div><div class="line">	int step = 1;</div><div class="line">	int x = p.x;</div><div class="line">	int y = p.y;</div><div class="line"></div><div class="line">	while (x &gt;= 1 &amp;&amp; x &lt;= c &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= r)</div><div class="line">	&#123;</div><div class="line">		step++;</div><div class="line">		//这一步也可以用二叉查找来找plants里面有没有x, y相对应的点</div><div class="line">		if(field[x][y] != 1 /* std::!binary_search(plants, plants + n, plants)*/) return 0;</div><div class="line"></div><div class="line">		x += dx;</div><div class="line">		y += dy;</div><div class="line">	&#125;</div><div class="line">	return step;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void input()</div><div class="line">&#123;</div><div class="line">	scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;n);</div><div class="line"></div><div class="line">	field = new int*[r + 1];</div><div class="line">	for (int i = 0; i &lt; r + 1; ++i)</div><div class="line">	&#123;</div><div class="line">		field[i] = new int[c + 1];</div><div class="line">	&#125;</div><div class="line">	//先初始化其为0</div><div class="line">	for (int i = 1; i &lt; r + 1; ++i)</div><div class="line">	&#123;</div><div class="line">		for (int j = 1; j &lt; c + 1; ++j)</div><div class="line">		&#123;</div><div class="line">			field[i][j] = 0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; n; ++i)</div><div class="line">	&#123;</div><div class="line">		scanf(&quot;%d %d&quot;, &amp;plants[i].x, &amp;plants[i].y);</div><div class="line">		field[plants[i].x][plants[i].y] = 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (int i = 1; i &lt; r + 1; ++i)</div><div class="line">	&#123;</div><div class="line">		for (int j = 1; j &lt; c + 1; ++j)</div><div class="line">		&#123;</div><div class="line">			printf(&quot;%d &quot;, field[i][j]);</div><div class="line">		&#125;</div><div class="line">		printf(&quot;\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int hatingFlog()</div><div class="line">&#123;</div><div class="line">	int dx, dy;</div><div class="line">	int max = 2;</div><div class="line">	int tmpStep;</div><div class="line">	input();</div><div class="line"></div><div class="line">	std::sort(plants, plants + n);</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; n - 1; ++i)</div><div class="line">	&#123;</div><div class="line">		for (int j = i + 1; j &lt; n; ++j)</div><div class="line">		&#123;</div><div class="line">			dx = plants[j].x - plants[i].x;</div><div class="line">			dy = plants[j].y - plants[i].y;</div><div class="line">			//如果第一个点的前一个点还在field内，则肯定不是最优答案的起点，换第二个点。</div><div class="line">			if (plants[i].x - dx &gt;= 1 &amp;&amp; plants[i].x - dx &lt;= c &amp;&amp; plants[i].y - dy &gt;= 1 &amp;&amp; plants[i].y &lt;= r)</div><div class="line">				continue;</div><div class="line">			//如果第一个点经过比max还小的step就越界了，肯定也不可能满足条件。</div><div class="line">			//由于是按x排好序的，再往后换第二个点必然也不满足条件，所以换第一个点。</div><div class="line">			if (plants[i].x + dx * (max - 1) &gt; r)</div><div class="line">				break;</div><div class="line"></div><div class="line">			//如果y方向过早越界</div><div class="line">			if (plants[i].y + dy * (max - 1) &gt; c || plants[i].y + dy * (max - 1) &lt; 1)</div><div class="line">				continue;</div><div class="line"></div><div class="line">			//如果三种提前的排除无法排除该店，那么算这条路径的step，看其是否为最大。</div><div class="line">			int tmpStep = searchPath(dx, dy, plants[i]);</div><div class="line">			if (tmpStep &gt; max) max = tmpStep;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if (max &lt;= 2) max = 0;</div><div class="line">	return max;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool operator &lt; (const Plant&amp; p1, const Plant&amp; p2)</div><div class="line">&#123;</div><div class="line">	if (p1.x == p2.x) return p1.y &lt; p2.y;</div><div class="line">	return p1.x &lt; p2.x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思路值得我们继续巩固的点有：<br>1，<strong>通过思考得到“局部”枚举的方式。</strong><br>2，对标准库里面函数的运用，sort, 包括binary_search的运用；当然，有很多时候我们对一些复杂的数据结构进行排序时，需要我们自己进行操作符重载。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/Cuda Beginning/" itemprop="url">
                  Cuda Beginning
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:35:30+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##前言</p>
<p>由于一直在学习图形学，很多时候，图形学中的计算，如最近碰到的问题，计算随机点的中垂面，每个点的计算K近邻树，都是独立的。如果用GPU并行加速，可能会有好的提速效果。再加上导师最想希望我和实验室学长开始做一个基于Cuda的项目，故想开始学CUDA。</p>
<h2 id="结构目录"><a href="#结构目录" class="headerlink" title="结构目录"></a>结构目录</h2><blockquote>
<ul>
<li>Cuda是什么</li>
<li>Cuda程序的编译过程</li>
<li>我的第一个Cuda程序</li>
<li>利用GPU加速Matrix Multiplication</li>
<li>优化策略1 : shared memory</li>
<li>优化策略2 : texture memroy</li>
<li>总结</li>
</ul>
</blockquote>
<h3 id="Cuda是什么"><a href="#Cuda是什么" class="headerlink" title="Cuda是什么"></a>Cuda是什么</h3><p>CUDA(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。而我们关心的事情有2点：</p>
<blockquote>
<ol>
<li>Cuda是对GPU运算能力的并行利用；</li>
<li>Cuda很好的兼容了C/C++，在此之上做了扩展；</li>
</ol>
</blockquote>
<p>听到过一个不错的比喻：　<br>CPU可以类比于一个强壮的男人，随机现在硬件能力的不断提升，单个CPU已经拥有了很强大的能力，甚至CPU也有了多核，同样也有很多基于CPU的多线程编程。<br>而GPU则是一群小孩，每一个能力不大，但是由于GPU可以同时开启成千上万个线程，&lt;线程格，线程块，线程&gt;，因此可以同时做很多事情，极大的提升程序的运行效率，这就是并行的好处。</p>
<p>tips : GPU是不适合做太多的逻辑判断的。它更希望能做一些简单的计算工作。</p>
<h3 id="Cuda程序的编译过程"><a href="#Cuda程序的编译过程" class="headerlink" title="Cuda程序的编译过程"></a>Cuda程序的编译过程</h3><p>Cuda程序一般分为两个部分，其中一部分是用Nvidia的编译器进行编译，在GPU上运行；另一部分，用原本的VS（我使用的编译器是Visual Studio）编译，在CPU上跑。<br><img src="http://images2015.cnblogs.com/blog/917758/201605/917758-20160505212820888-1718051162.png" alt="Nvcc的编译过程"><br>Cuda C是支持C/C++语言的。它只对C语言做了一个很小的扩展并且提供了一个C runtime library.<br>想要知道Cuda是怎么运行的，我们首先要知道Cuda程序的编译过程。</p>
<h4 id="NVCC-的工作流主要分下面几步："><a href="#NVCC-的工作流主要分下面几步：" class="headerlink" title="NVCC 的工作流主要分下面几步："></a><em>NVCC</em> 的工作流主要分下面几步：</h4><p>1，将程序中的host code 和 device code 区别开来。<br>2，将device code进行转化可装配形式（assembly form (PTX code)），进而转化成2进制流，用于交给GPU处理。<br>3，将Host code中不符合C语言标准的代码进行替换，然后按照正常的编译过程进行编译链接，在CPU中处理。</p>
<h4 id="Kernel-核函数"><a href="#Kernel-核函数" class="headerlink" title="Kernel 核函数"></a><em>Kernel</em> 核函数</h4><pre><code>核函数是作用在GPU上，用____global____定义，相当于是cuda提供给C/C++的一个接口，每次可以同时调用多个核函数，每个线程都会执行这个核函数，线程块和线程的数量可以自己根据计算的规模和硬件条件来设定。核函数是cuda编程的核心，在之后的例子中我们也能看到。
</code></pre><h4 id="Initialization-初始化过程："><a href="#Initialization-初始化过程：" class="headerlink" title="Initialization 初始化过程："></a><em>Initialization</em> 初始化过程：</h4><pre><code>一般来说，Cuda并没有一个明确的开始标识，当第一个runtime function被调用的时候，GPU section就被初始化了。在初始化的过程中，会创建一个cuda contexet，初始创建的这个cuda环境是主要环境，被所有的host所共享。*cudaDeviceReset()*可以destory当前的上下文，直至下一个runtime function被调用时，将重新创建primary context。
</code></pre><h4 id="Device-Memory-设备内存："><a href="#Device-Memory-设备内存：" class="headerlink" title="Device Memory 设备内存："></a><em>Device Memory</em> 设备内存：</h4><pre><code>设备内存相当于是GPU中的内存，一般的分配方法有两种，线性内存或者cuda arrays，其中cuda arrays是和纹理内存相关的，我们后续再谈。
线性内存通常使用*cudaMalloc()*分配，*cudaFree()*释放，*cudaMemcpy()*在主机和设备之间传递数据。
</code></pre><h3 id="我的第一个Cuda程序"><a href="#我的第一个Cuda程序" class="headerlink" title="我的第一个Cuda程序"></a>我的第一个Cuda程序</h3><p>给出一个最基本的例子，也是在Visual Studio上创建一个.cu文件时，会自动生成的一个示例代码。</p>
<p>输入：两个长度一样的数组，假设长度为5；<br>输出：一个结果数组，数组里面的每一个数是2个输入数组里对应位置的和。</p>
<p>CPU思路，这是一道简单得不能再简单的题，通常CPU中的算法必然是定义一个循环，遍历2个输入数组并将他们对应元素的和相加，得到结果数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(int i = 0; i &lt; 5; ++i)</div><div class="line">&#123;</div><div class="line">    _c[i] = a[i] + b[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，CPU中进行的是五次串行运算。</p>
<p>那么回到我们想要实现的GPU并行计算。之前也提到过，GPU是通过调用核函数来调用进程的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> // Launch a kernel on the GPU with one thread for each element.</div><div class="line">  addKernel&lt;&lt;&lt;1, 5&gt;&gt;&gt;(dev_c, dev_a, dev_b);</div><div class="line">    </div><div class="line">    __global__ void addKernel(int *c, const int *a, const int *b)</div><div class="line">&#123;</div><div class="line">    int i = threadIdx.x;</div><div class="line"></div><div class="line">    c[i] = a[i] + b[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以大致想象，我们开启了5个线程，然后通过thread.x来获取所在线程的信息，同时计算结果数组C，以此来实现并行的效果。当然，在GPU中需要单独分配和释放内存，同时数据也会在CPU和GPU中来回传递，这个Cuda都已经为我们提供好了相应的接口，后续我们会继续介绍。</p>
<h3 id="利用GPU加速Matrix-Multiplication"><a href="#利用GPU加速Matrix-Multiplication" class="headerlink" title="利用GPU加速Matrix Multiplication"></a>利用GPU加速Matrix Multiplication</h3><h4 id="1，矩阵乘法的CPU思路"><a href="#1，矩阵乘法的CPU思路" class="headerlink" title="1，矩阵乘法的CPU思路"></a>1，矩阵乘法的CPU思路</h4><p>在这里我是默认读者已经有基本的矩阵运算基础的。所以不难想到，对于CPU的矩阵乘法算法如下：<br>由于，对于C中的每一个数，都要经过n次乘法运算，因此总的时间复杂度应该是O(n^3)。<br>对于计算两个1024*1024的输入方阵，CPU串行计算时间大概在9000ms左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//CPU version 其中C是结果矩阵，AB是输入矩阵。</div><div class="line">void MatrixMulCPU(float *_C, const float* _A, const float* _B, int WA, int HA, int WB, int HB)</div><div class="line">&#123;</div><div class="line">	if (WA != HB)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;the matrix A and B cannot be multipled!&quot;);</div><div class="line">			exit(0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; HA; ++i)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt; WB; ++j)</div><div class="line">		&#123;</div><div class="line">			for (int k = 0; k &lt; WA; ++k)</div><div class="line">			&#123;</div><div class="line">				_C[i * WA + j] += _A[i * WA + k] * _B[k * WB + j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2，GPU优化思路。"><a href="#2，GPU优化思路。" class="headerlink" title="2，GPU优化思路。"></a>2，GPU优化思路。</h4><p>借矩阵乘法的GPU算法，我在这里完整地说一下GPU调用核函数的方法。<br>首先申请的是CPU上的内存，也即是host memory。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   const int width_A = 1024;</div><div class="line">const int height_A = 1024;</div><div class="line">const int width_B = 1024;</div><div class="line">const int height_B = 1024;</div><div class="line"></div><div class="line">float *B = (float *)malloc(sizeof(float) * height_B * width_B);</div><div class="line">float *A = (float *)malloc(sizeof(float) * height_A * width_A);</div><div class="line">float *C = (float *)malloc(sizeof(float) * height_A * width_B);</div></pre></td></tr></table></figure></p>
<p>我是给了A,B矩阵0-100的随机数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//产生随机数生成器</div><div class="line">	srand((unsigned)time(0));</div><div class="line"></div><div class="line">	randomInit(B, height_B * width_B);</div><div class="line">	randomInit(A, height_A * width_A);</div></pre></td></tr></table></figure></p>
<p>之后申请device memory，并且把A, B所在内存拷贝过GPU上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   float *dev_a = 0;</div><div class="line">float *dev_b = 0;</div><div class="line">float *dev_c = 0;</div><div class="line"></div><div class="line">cudaError_t cudaStatus;</div><div class="line">// Choose which GPU to run on, change this on a multi-GPU system.</div><div class="line">   cudaStatus = cudaSetDevice(0);</div><div class="line">   </div><div class="line">   cudaStatus = cudaMalloc((void**)&amp;dev_c, HA * WB * sizeof(float));</div><div class="line">   </div><div class="line">   cudaStatus = cudaMemcpy(dev_a, a, HA * WA * sizeof(float), cudaMemcpyHostToDevice);</div><div class="line">   cudaStatus = cudaMemcpy(dev_b, b, HB * WB * sizeof(float), cudaMemcpyHostToDevice);</div></pre></td></tr></table></figure></p>
<p>到这一步后，我们的准备工作就算是做好了，之后的工作是自己来设定，我们需要在GPU上开启多少个线程，这个你可以把它也视为核函数的一个参数，并且把这些device上的内存地址当作参数传递给核函数。</p>
<p>在这个基本的GPU算法中，我们为C的每一行每一列都设置一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//为每一个C[i][j]设置一个线程进行计算</div><div class="line">int block_size = 16;</div><div class="line"></div><div class="line">dim3 Threads(block_size, block_size);</div><div class="line">dim3 Blocks(WB / block_size, HA / block_size);</div><div class="line"></div><div class="line">//用这个方式来调用核函数</div><div class="line">MatrixMulGPU_1 &lt;&lt; &lt;Blocks, Threads &gt;&gt;&gt;(dev_c, dev_a, dev_b, WA, WB);</div></pre></td></tr></table></figure></p>
<p>核函数，我们通过blockIdx和threadIdx索引获得当前是哪个线程，来计算它所负责的部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">__global__ void MatrixMulGPU_1(float *c, const float *a, const float *b, unsigned int WA, unsigned int WB)</div><div class="line">&#123;</div><div class="line">	float sum = 0;</div><div class="line">	//找出该线程所在的行和列</div><div class="line">	int row = blockIdx.y * blockDim.y + threadIdx.y;</div><div class="line">	int col = blockIdx.x * blockDim.x + threadIdx.x;</div><div class="line"></div><div class="line">	//线程Thread(row, col)负责计算C(row, col)</div><div class="line">	for (int i = 0; i &lt; WB; ++i)</div><div class="line">	&#123;</div><div class="line">		sum += a[row * WA + i] * b[i * WB + col];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	c[row * WB + col] = sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，每个线程只进行了N次运算，而每个线程之前是并行的，所以时间理论上只是O(n)，虽然在拷贝内存上还需要花费一些时间，但是从O(n^3)-&gt;O(n)这个提升也是巨大的，对时间的统计数据显示也是如此。从9000ms提升到50ms左右。</p>
<h3 id="优化政策1，shared-memory"><a href="#优化政策1，shared-memory" class="headerlink" title="优化政策1，shared memory"></a>优化政策1，shared memory</h3><p>那么在实现了基本的矩阵GPU算法后，我们还有没有什么方法继续优化我们的算法，使得速度进一步提高呢？结果是肯定的。在之前的算法中，我们的每一个C[i][j]都算了n次，而在这n次取数的过程中，还有我们可以做的很多事情。首先我们可以对每一行每一列进行细分，划分成更细的block_size大小（可以自己来设定），然后再计算每个block_size*block_size时，我们设计一个共享区，然后让数的计算存这个共享区中取数，就可以减少取数的时间。下面是相应的代码，可以在英伟达的标准实例代码中找到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">template&lt;int BLOCK_SIZE&gt; __global__ void MatrixMulGPU_2(float *c, const float *a, const float *b, unsigned int WA, unsigned int WB)</div><div class="line">&#123;</div><div class="line">	// Block index</div><div class="line">	int bx = blockIdx.x;</div><div class="line">	int by = blockIdx.y;</div><div class="line"></div><div class="line">	// Thread index</div><div class="line">	int tx = threadIdx.x;</div><div class="line">	int ty = threadIdx.y;</div><div class="line"></div><div class="line">	// Index of the first sub-matrix of A processed by the block</div><div class="line">	int aBegin = WA * BLOCK_SIZE * by;</div><div class="line"></div><div class="line">	// Index of the last sub-matrix of A processed by the block</div><div class="line">	int aEnd = aBegin + WA - 1;</div><div class="line"></div><div class="line">	// Step size used to iterate through the sub-matrices of A</div><div class="line">	int aStep = BLOCK_SIZE;</div><div class="line"></div><div class="line">	// Index of the first sub-matrix of B processed by the block</div><div class="line">	int bBegin = BLOCK_SIZE * bx;</div><div class="line"></div><div class="line">	// Step size used to iterate through the sub-matrices of B </div><div class="line">	int bStep = BLOCK_SIZE * WB;</div><div class="line"></div><div class="line">	// Csub is used to store the element of the block sub-matrix</div><div class="line">	// that is computed by the thread</div><div class="line">	float Csub = 0;</div><div class="line"></div><div class="line">	// Loop over all the sub-matrices of A and B</div><div class="line">	// required to compute the block sub-matrix</div><div class="line">	for (int i = aBegin, j = bBegin;</div><div class="line">		i &lt;= aEnd;</div><div class="line">		i += aStep, j += bStep)</div><div class="line">	&#123;</div><div class="line"></div><div class="line">		// Declaration of the shared memory array As used to</div><div class="line">		// store the sub-matrix of A</div><div class="line">		__shared__ float As[BLOCK_SIZE][BLOCK_SIZE];</div><div class="line"></div><div class="line">		// Declaration of the shared memory array Bs used to</div><div class="line">		// store the sub-matrix of B</div><div class="line">		__shared__ float Bs[BLOCK_SIZE][BLOCK_SIZE];</div><div class="line"></div><div class="line">		// Load the matrices from device memory</div><div class="line">		// to shared memory; each thread loads</div><div class="line">		// one element of each matrix</div><div class="line">		As[ty][tx] = a[i + WA * ty + tx];</div><div class="line">		Bs[ty][tx] = b[j + WB * ty + tx];</div><div class="line"></div><div class="line">		// Synchronize to make sure the matrices are loaded</div><div class="line">		__syncthreads();</div><div class="line"></div><div class="line">		// Multiply the two matrices together;</div><div class="line">		// each thread computes one element</div><div class="line">		// of the block sub-matrix</div><div class="line">#pragma unroll</div><div class="line"></div><div class="line">		for (int k = 0; k &lt; BLOCK_SIZE; ++k)</div><div class="line">		&#123;</div><div class="line">			Csub += As[ty][k] * Bs[k][tx];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Synchronize to make sure that the preceding</div><div class="line">		// computation is done before loading two new</div><div class="line">		// sub-matrices of A and B in the next iteration</div><div class="line">		__syncthreads();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Write the block sub-matrix to device memory;</div><div class="line">	// each thread writes one element</div><div class="line">	int k = WB * BLOCK_SIZE * by + BLOCK_SIZE * bx;</div><div class="line">	c[k + WB * ty + tx] = Csub;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<em>syncthreads()</em>是用于保证同步的，每一个线程在运行到这一步时，都会停下来等待，直至所有进程都进行到这才会继续下去，以此来保证同步。</p>
<h3 id="优化政策2，-Texture-Memory"><a href="#优化政策2，-Texture-Memory" class="headerlink" title="优化政策2， Texture Memory"></a>优化政策2， Texture Memory</h3><p>纹理这一块，我的理解是，一般的内存都是线性存放的，不论是二维或者是三维，但存放的本质就是串行线性。故在访问例如 a[1][2]和a[1][3]时，比访问a[1][2]和a[2][2]时，后者的耗时要多一些。但对于纹理，就不会出现这样的问题，以此来提高访问效率。</p>
<p>首先，先声明纹理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">texture&lt;float, 2, cudaReadModeElementType&gt; texA;</div><div class="line">texture&lt;float, 2, cudaReadModeElementType&gt; texB;</div></pre></td></tr></table></figure></p>
<p>然后以cudaArray为介质，将内存中的数放到纹理中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//GPU mode3 with texture memory</div><div class="line"></div><div class="line">		cudaChannelFormatDesc channelDescA = cudaCreateChannelDesc((int)sizeof(float) * 8, 0, 0, 0, cudaChannelFormatKindFloat);</div><div class="line">		cudaChannelFormatDesc channelDescB = cudaCreateChannelDesc((int)sizeof(float) * 8, 0, 0, 0, cudaChannelFormatKindFloat);</div><div class="line"></div><div class="line">		cudaArray* mat_A;</div><div class="line">		cudaArray* mat_B;</div><div class="line"></div><div class="line">		cudaMallocArray(&amp;mat_A, &amp;channelDescA, width_A, height_A);</div><div class="line">		cudaMallocArray(&amp;mat_B, &amp;channelDescB, width_B, height_B);</div><div class="line"></div><div class="line">		cudaMemcpyToArray(mat_A, 0, 0, A, sizeof(float) * height_A * width_A, cudaMemcpyHostToDevice);</div><div class="line">		cudaMemcpyToArray(mat_B, 0, 0, B, sizeof(float) * height_B * width_B, cudaMemcpyHostToDevice);</div></pre></td></tr></table></figure></p>
<p>接着设置纹理的相关属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">texA.addressMode[0] = cudaAddressModeWrap;</div><div class="line">texA.addressMode[1] = cudaAddressModeWrap;</div><div class="line">texA.filterMode = cudaFilterModePoint;</div><div class="line">texA.normalized = false;</div><div class="line">texB.addressMode[0] = cudaAddressModeWrap;</div><div class="line">   texB.addressMode[1] = cudaAddressModeWrap;</div><div class="line">texB.filterMode = cudaFilterModePoint;</div><div class="line">texB.normalized = false;</div></pre></td></tr></table></figure></p>
<p>最后纹理的相关核函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">__global__ void MatrixMul(float *c, unsigned int w, unsigned int h)</div><div class="line">&#123;</div><div class="line">	float sum = 0;</div><div class="line">	//找出该线程所在的行和列</div><div class="line">	int row = blockIdx.y * blockDim.y + threadIdx.y;</div><div class="line">	int col = blockIdx.x * blockDim.x + threadIdx.x;</div><div class="line"></div><div class="line">	/*</div><div class="line">	//计算纹理坐标</div><div class="line">	float u = row / (float)w;</div><div class="line">	float v = col / (float)h;</div><div class="line">	//线程Thread(row, col)负责计算C(row, col)</div><div class="line">	u -= 0.5f;</div><div class="line">	v -= 0.5f;</div><div class="line">	*/</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; w; ++i)</div><div class="line">	&#123;</div><div class="line">		sum += tex2D(texA, i, row) * tex2D(texB, col, i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	c[row * w + col] = sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到用2维纹理来访问我们相关的矩阵，是非常方便的，只需要用tex2D()就行。</p>
<p>最后是这些方法的截图。<br><img src="http://ww4.sinaimg.cn/mw690/a207cfd8gw1f4448xxjsyj20it0cbwfx.jpg" alt="结果截图"></p>
<p>注：在release版本中，使用texture优化的时间比正常的GPU算法要慢，这个现象由于矩阵乘法本身对取数是 有一定规律性的，而texture优化对一些随机访问内存算法比较有效，在此我们不深究，只为学习纹理内存用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-10T19:22:55+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/13774767?v=3&s=466"
               alt="Storm han" />
          <p class="site-author-name" itemprop="name">Storm han</p>
          <p class="site-description motion-element" itemprop="description">拿梦想做赌注，我怎么舍得输？</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/stormHan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/han-jia-wei" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Storm han</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
