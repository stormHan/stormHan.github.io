<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Fighting Life!" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="拿梦想做赌注，我怎么舍得输？">
<meta property="og:type" content="website">
<meta property="og:title" content="Han's Blog Cell">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Han's Blog Cell">
<meta property="og:description" content="拿梦想做赌注，我怎么舍得输？">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Han's Blog Cell">
<meta name="twitter:description" content="拿梦想做赌注，我怎么舍得输？">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Han's Blog Cell </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Han's Blog Cell</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hi, My world!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/25/原子操作/" itemprop="url">
                  原子操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-25T11:19:33+08:00" content="2016-11-25">
              2016-11-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-为什么需要使用原子操作"><a href="#1-为什么需要使用原子操作" class="headerlink" title="1.为什么需要使用原子操作"></a>1.为什么需要使用原子操作</h2><p>对于一些（Read-Modify-Write）操作。在多个线程同时对同一地址进行操作时，根据线程的调度方式的不同，可能产生不同的结果（有的正确，有的错误）。而我们对于这种不确定性是绝对不能容忍的。</p>
<h2 id="2-exmaple"><a href="#2-exmaple" class="headerlink" title="2.exmaple"></a>2.exmaple</h2><p>在计算直方图问题中，如果直接采取GPU并行统计出现的次数，并将数据直接<strong>原子加</strong>到全局变量中。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__global__ void histo_kernel( unsigned char *buffer,</div><div class="line">                              long size,</div><div class="line">                              unsigned int *histo ) &#123;</div><div class="line">    // calculate the starting index and the offset to the next</div><div class="line">    // block that each thread will be processing</div><div class="line">    int i = threadIdx.x + blockIdx.x * blockDim.x;</div><div class="line">    int stride = blockDim.x * gridDim.x;</div><div class="line">    while (i &lt; size) &#123;</div><div class="line">        atomicAdd( &amp;histo[buffer[i]], 1 );</div><div class="line">        i += stride;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>性能是相当慢的，（比CPU的还慢了几倍）。<br>为了避免这种大量的线程往同一块较小内存中写数据的情况发生，我们利用shared memory提升性能。这种技巧并没有减少原子操作的次数，相反是增大了，同时又共享内存原子操作和全局内存原子操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">__global__ void histo_kernel( unsigned char *buffer,</div><div class="line">                              long size,</div><div class="line">                              unsigned int *histo ) &#123;</div><div class="line"></div><div class="line">    // clear out the accumulation buffer called temp</div><div class="line">    // since we are launched with 256 threads, it is easy</div><div class="line">    // to clear that memory with one write per thread</div><div class="line">    __shared__  unsigned int temp[256];</div><div class="line">    temp[threadIdx.x] = 0;</div><div class="line">    __syncthreads();</div><div class="line"></div><div class="line">    // calculate the starting index and the offset to the next</div><div class="line">    // block that each thread will be processing</div><div class="line">    int i = threadIdx.x + blockIdx.x * blockDim.x;</div><div class="line">    int stride = blockDim.x * gridDim.x;</div><div class="line">    while (i &lt; size) &#123;</div><div class="line">        atomicAdd( &amp;temp[buffer[i]], 1 );</div><div class="line">        i += stride;</div><div class="line">    &#125;</div><div class="line">    // sync the data from the above writes to shared memory</div><div class="line">    // then add the shared memory values to the values from</div><div class="line">    // the other thread blocks using global memory</div><div class="line">    // atomic adds</div><div class="line">    // same as before, since we have 256 threads, updating the</div><div class="line">    // global histogram is just one write per thread!</div><div class="line">    __syncthreads();</div><div class="line">    atomicAdd( &amp;(histo[threadIdx.x]), temp[threadIdx.x] );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如在直方图计算中看到得，有时候依赖原子操作会带来性能问题，并且这些问题只能通过算法的某些部分进行重构来加以解决。但是在直方图实例中，我们使用了一种两阶段算法，该算法降低了在全局内存访问上竞争程度。通常，这种降低内存竞争程度的策略总能带来不错的效果，因此在使用原子操作的时候，要记住这种策略。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/纹理内存/" itemprop="url">
                  纹理内存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T16:37:45+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与常量内存类似，纹理内存同样缓存在芯片上，因此在某些情况中，它能减少对内存的请求并提供更高效的内存带宽。纹理缓存是专门为那些在内存访问模式中存在大量空间局部性（Spatial Locality）的图形应用程序而设计的。在某个计算应用程序中，这意味着一个线程读取的位置可能与邻近线程读取的位置“非常接近”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//一维纹理</div><div class="line">texture&lt;float&gt; texIn;</div><div class="line">texture&lt;float&gt; texOut;</div><div class="line"></div><div class="line">cudaBindTexture(NULL, texIn, data.inSrc, size);</div><div class="line">cudaBindTexture(NULL, texOut, data.outSrc, size);</div><div class="line"></div><div class="line">//不同与其它内存用方括号访问内存，纹理内存用内置函数访问</div><div class="line">float f1 = tex1Dfetch(texIn, pos1);</div><div class="line">float f2 = tex1Dfetch(texOut, pos2);</div><div class="line">//核函数中无需将纹理内存作为参数传入</div><div class="line"></div><div class="line">cudaUnbindTexture(texIn);</div><div class="line">cudaUnbindTexture(texOut);</div><div class="line"></div><div class="line">//二维纹理</div><div class="line">texture&lt;float, 2&gt; texIn;</div><div class="line">texture&lt;float, 2&gt; texOut;</div><div class="line"></div><div class="line">//使用tex2D时，不需要担心发生溢出的问题。如果参数x,y小于0或某个值大于宽度，则会返回位于0或者宽度位置的值。（注意，在有些应用程序中需要这种行为，而有些则需要避免该行为的发生）</div><div class="line"></div><div class="line">float t = tex2D(texIn, x, y);</div><div class="line">//与一维纹理相同的是，都需要预先分配存储空间。但不同的是，二维纹理要求提供一个cudaChannelFormatDesc,对通道格式描述符的声明。</div><div class="line">cudaChannelFormatDesc desc = cudaCreateChannelDesc&lt;float&gt;();</div><div class="line">//这里使用默认的参数，仅仅指定浮点描述符。</div><div class="line">cudaBindTexture2D(NULL, texIn, data.Insrc, desc, DIM, DIM, size);</div><div class="line">//同样是使用cudaUnbindTexture（texIn）来解除绑定。</div></pre></td></tr></table></figure>
<p>注意，无论是使用2维纹理还是1维纹理，性能基本相同，只是在有些情况下，2维纹理的代码会更简单直观一些。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/常量内存和GPU事件性能测试/" itemprop="url">
                  常量内存和GPU事件性能测试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T15:31:59+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常量内存"><a href="#常量内存" class="headerlink" title="常量内存"></a>常量内存</h2><p>常量内存首先，顾名思义，是不会发生变化的。<br>其次，在GPU中，访问常量内存，对<strong>常量</strong>内存的读操作可以广播到该线程的“邻近”线程，而什么是“邻近”线程呢，在此需要引入<strong>线程束</strong>的概念。</p>
<h3 id="线程束Warp"><a href="#线程束Warp" class="headerlink" title="线程束Warp"></a>线程束Warp</h3><p>这里的warp并不是《星际迷航》电影中的曲速引擎（Warp Drive）,而是来自纺织（Weaving）领域的概念。线程束可以看成是一组线程通过交织而形成的一个整体。在cuda架构中，线程束是指一个包含32个线程的集合，这个线程集合被“编织在一起”并且以“步调一致（LOCKSTEP）”的形式执行。在程序中的每一行，线程束中的每个线程都将在不同的数据上执行相同的指令。</p>
<h3 id="使用常量内存的优势"><a href="#使用常量内存的优势" class="headerlink" title="使用常量内存的优势"></a>使用常量内存的优势</h3><p>当处理常量内存时，NVIDIA硬件将把单词内存读取操作广播到每个半线程束（Half-Warp）。在半线程束中包含了16个线程。如果在半线程束中的每个线程都从常量内存的相同地址上读取数据，那么GPU只会产生一次读取请求并在随后将数据广播到每个线程。如果从常量内存中读取大量的数据，那么这种方式产生的内存流量只是使用全局内存的（1/16）。<br>同时，由于读取常量内存时，内容是不会发生变化的，因此硬件将主动把这个常量数据缓存在GPU上。那么在第一次从常量内存的地址上读取后，当其他半线程束请求同一地址时，那么将命中缓存，这同样减少了额外的内存流量。</p>
<h3 id="使用常量内存的缺点"><a href="#使用常量内存的缺点" class="headerlink" title="使用常量内存的缺点"></a>使用常量内存的缺点</h3><p>然而当使用常量内存时，也可能造成性能的下降。当半线程内的线程访问的数据不同时，将会串行的访问常量内存。如分别读取不同的地址时，则需要16倍的时间来发出请求，这是一个权衡的过程。</p>
<h2 id="事件性能测试"><a href="#事件性能测试" class="headerlink" title="事件性能测试"></a>事件性能测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cudaEvent_t start, stop;</div><div class="line">cudaEventCreate(&amp;start);</div><div class="line">cudaEventCreate(&amp;stoo);</div><div class="line">cudaEventRecord(start, 0);</div><div class="line"></div><div class="line">//在GPU上执行一些工作</div><div class="line"></div><div class="line">cudaEventRecord(stop, 0);</div><div class="line">cudaEventSynchronize(stop);//防止cpu代码在gpu代码还在执行时就记录了时间而导致测试不准。</div><div class="line"></div><div class="line">float elapsedTime;</div><div class="line">cudaEventElapsedTime(&amp;elapsedTime, start, stop);</div><div class="line">cudaEventDestory(start);</div><div class="line">cudaEventDestory(stop);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/Effective C++ --让自己习惯C++(02)/" itemprop="url">
                  Effective C++ --让自己习惯C++(02)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T21:37:05+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一，Use-const-whenever-possible-03"><a href="#一，Use-const-whenever-possible-03" class="headerlink" title="一，Use const whenever possible.(03)"></a>一，Use const whenever possible.(03)</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><strong>const</strong>是一个强大的武器，它允许你指定一个语义约束（指定一个“不该被改动”的对象），然后通过编译器来行使这项约束。而我们应该做的事情就是，只要这（某值应该保持不变）是一个事实，那么久该尽可能的说出来，获得编译器的襄助，减少程序出错的可能。</p>
<p>下面记录一些我觉得自己还不太熟的tips:<br>1，const在*左右分别表示 是指针指向的数值为const还是指针本身是const。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char greeting[] = &quot;Hello&quot;</div><div class="line">char* p = greeting;         //not-const pointer, non-const data</div><div class="line">const char* p = greeting;   //non-const pointer, const data</div><div class="line">char* const p = greeting;   //const pointer, non-const data</div><div class="line">const char* const p = greeting; // const pointer, const data</div></pre></td></tr></table></figure></p>
<p>2，const在函数前，表示其返回值是const不能被修改；const如果为函数参数，表示该参数在函数中不可被修改；const如果修饰函数本身，则这个函数是bitwise const的，不可修改任何关于对象的内容。</p>
<p>3，const 和 const-non函数，可以够成重载。但是这往往会导致大量代码的重复。我们可以通过让non-const函数调用const函数实现常量性转移（casting away constness）（不可反向）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//for example</div><div class="line">class TextBlock&#123;</div><div class="line">public:</div><div class="line">	TextBlock(string s)</div><div class="line">	&#123;</div><div class="line">		text = s;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	char&amp; operator [](size_t t)</div><div class="line">	&#123;</div><div class="line">		return const_cast&lt;char&amp;&gt; (</div><div class="line">			static_cast&lt;const TextBlock&amp;&gt;(*this)[t]</div><div class="line">			);</div><div class="line">	&#125;</div><div class="line">	const char&amp; operator [](size_t t) const</div><div class="line">	&#123;</div><div class="line">		return text[t];</div><div class="line">	&#125;</div><div class="line">private:</div><div class="line">	string text;</div><div class="line"></div><div class="line">	//即使在const函数中，也加油被修改</div><div class="line">	mutable bool flag;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/08/Effective C++ --让自己习惯C++(01)/" itemprop="url">
                  Effective C++ --让自己习惯C++(01)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-08T11:02:34+08:00" content="2016-11-08">
              2016-11-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一，View-C-as-a-federation-of-languages-01"><a href="#一，View-C-as-a-federation-of-languages-01" class="headerlink" title="一，View C++ as a federation of languages.(01)"></a>一，View C++ as a federation of languages.(01)</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>将C++视为一个由相关语言组成的语言联邦。<br>在某个次语言(sublanguage)中，各种守则与通例都倾向于简单，直观。然而当从一个次语言转移到另一个次语言中时，守则可能改变。而其主要的次语言总共有四个：</p>
<blockquote>
<blockquote>
<p>1，C语言。C++以C为基础，很多的概念来源于C，blocks, statements, preprocessor, built-in data types, arrays, pointers。但C也有其局限性：没有模板（templates），没有异常（exceptions），没有重载（overloading）</p>
<p>2，Object-Oriented C++。这一部分是面向对象设计古典守则在C++上最直接的实施。也是C with classes所诉求的：classes（包括构造函数，析构函数），封装（encapsulation），继承（inheritance），多态（polymorphism），virtual函数（动态绑定）。</p>
<p>3，Template C++。C++的泛型编程，也是大多数程序员经验最少的部分。Template相关考虑与设计已经弥漫整个C++，良好编程守则中“唯template”适用的特殊条款并不罕见。</p>
<p>4，STL。一个template程序库，对容器（containers），迭代器（iterators），算法（algorithms）已经函数对象的规约有极佳的紧密配合与协调。</p>
</blockquote>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住这四个次语言，当你从某个次语言切换到另一个，导致高效变成守则要求你改变策略时，不要感到惊讶。例如对内置类型而言pass-by-value通常比pass-by-reference高效，但当你从C part of C++移往Object-Oriented-C++时，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，运用TemplateC++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数都是在C指针之上塑造的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则再次适用。</p>
<p>因此C++是四个次语言组成的语言联邦政府，每个语言都有自己的规约。记住这四个次语言你就会发现C++容易理解很多。</p>
<h1 id="Prefer-consts-enums-and-inlines-to-defines-02"><a href="#Prefer-consts-enums-and-inlines-to-defines-02" class="headerlink" title="Prefer consts, enums, and inlines to #defines.(02)"></a>Prefer consts, enums, and inlines to #defines.(02)</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><p><strong>尽量减少#define的使用，多让编译器去工作而不是让预处理器工作！！</strong><br>原因一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define RATIO 1.635</div><div class="line">//也许从未被编译器看见而被预处理器拿走从而会报错。</div><div class="line"></div><div class="line">const double Ratio = 1.635；//这样则不会出问题</div></pre></td></tr></table></figure>
<p> 在声明常量（通常放在头文件里）的时候需要注意两个问题<br> 1， 常量字符串<br> const char* const authorNmae = “Scott Meyers”<br> 2，类常量，不需要每个对象都有自己的常量，故为静态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class GamePlayer&#123;</div><div class="line"> private:</div><div class="line">    static const int Number = 5;</div><div class="line">    int scores[Number];</div><div class="line">    ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意，这里的number只是声明式，（相当于函数只声明了还没实现）。如果需要取这个常量的地址，则需要在实现文件里写它的定义式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const int GamePlayer::Number; //Number 的定义，此时不需要再赋值</div></pre></td></tr></table></figure></p>
<p>原因二：</p>
<p> #define是不重视域的。这意味着#define不仅不能够用来定义class的专属常量，而且不能提供任何的封装性。</p>
<p> 原因三：<br> 不推荐使用预处理器来实现宏（macros）。宏看起来很像函数，其优点是不会招致函数调用的额外开销。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define CALL_WITH_MAX(a, b) f((a)&gt;(b) &gt; (a) : (b))</div></pre></td></tr></table></figure></p>
<p><strong>这种宏是有很多缺点的！</strong><br>首先，再你写出这种宏的时候，你必须要为每一个实参加上小括号！否则某人在<strong>表达式</strong>中调用这个宏就会遭遇麻烦。但纵然如此，也不可避免会出现麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a = 5;</div><div class="line">int b = 0;</div><div class="line"></div><div class="line">   CALL_WITH_MAX(++a, b);        //a = 7 </div><div class="line">CALL_WITH_MAX(++a, b + 10);   //a = 6</div></pre></td></tr></table></figure></p>
<p>结果甚至会因为比较的值不同而不同，相当于程序错误。（其原因是参数被核算多次）。<br>而推荐使用的是template inline函数，既可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">inline void callWithMax(const T&amp; a, const T&amp; b)</div><div class="line">&#123;</div><div class="line">    f(a &gt; b ? a : b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了consts, enums和inlines，我们对于预处理器（特别是#define）的需求降低了，但并非完全消除。#include依然是必需品，而#ifdef / #ifndef也继续扮演着控制编译的重要角色。目前还不到预处理全面而退的时候，但你应该明确地给予它更长更频繁的假期！</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>对于单纯常量，最好以const对象或者enum替换#define。</strong><br><strong>对于形似函数的宏，最好改用inline函数替代#define。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/08/Trie树/" itemprop="url">
                  Trie树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-08T11:02:34+08:00" content="2016-11-08">
              2016-11-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Trie(字典树)可以保存一些字符串-&gt;值得对应关系，其实它和hashmap的功能相同，以key-value映射的方式用空间换时间。（只不过Trie的key往往就是字符串）</p>
<p>Trie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key（也就是字符串的size） 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就肯定会是 O(k) ，而且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。</p>
<p>Trie树有一些特性：<br>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>3）每个节点的所有子节点包含的字符都不相同。<br>4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。<br>5）插入查找的复杂度为O(n)，n为字符串长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">struct Trie_node</div><div class="line">&#123;</div><div class="line">	bool exist;</div><div class="line">	Trie_node* next[26];</div><div class="line">	int count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Trie_node* createTrie()</div><div class="line">&#123;</div><div class="line">	Trie_node* root = new Trie_node();</div><div class="line">	root-&gt;count = 0;</div><div class="line">	root-&gt;exist = false;</div><div class="line">	memset(root-&gt;next, 0, sizeof(root-&gt;next));</div><div class="line"></div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void deleteTrie(Trie_node* root)</div><div class="line">&#123;</div><div class="line">	for (int i = 0; i &lt; 26; ++i)</div><div class="line">	&#123;</div><div class="line">		if (root-&gt;next[i] != NULL)</div><div class="line">			deleteTrie(root-&gt;next[i]);</div><div class="line">	&#125;</div><div class="line">	delete root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void insert(Trie_node* root, string word)</div><div class="line">&#123;</div><div class="line">	int nb = word.size();</div><div class="line">	if (nb == 0) return;</div><div class="line"></div><div class="line">	Trie_node* pt = root;</div><div class="line">	root-&gt;count++;</div><div class="line">	for (int i = 0; i &lt; nb; ++i)</div><div class="line">	&#123;</div><div class="line">		int p = word[i] - &apos;a&apos;;</div><div class="line">		if (pt-&gt;next[p] == NULL)</div><div class="line">		&#123;</div><div class="line">			Trie_node* tt = new Trie_node();</div><div class="line">			tt-&gt;count = 1;</div><div class="line">			memset(tt, NULL, sizeof(tt-&gt;next));</div><div class="line">			if (i == nb - 1)</div><div class="line">				tt-&gt;exist = true;</div><div class="line">			else</div><div class="line">				tt-&gt;exist = false;</div><div class="line">			pt-&gt;next[p] = tt;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			pt-&gt;next[p]-&gt;count++;</div><div class="line">			if (i == nb - 1)</div><div class="line">				pt-&gt;next[p]-&gt;exist = true;</div><div class="line">		&#125;</div><div class="line">		pt = pt-&gt;next[p];</div><div class="line">	&#125;</div><div class="line">	return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int find(Trie_node* root, string word)</div><div class="line">&#123;</div><div class="line">	int nb = word.size();</div><div class="line">	if (nb == 0) return 0;</div><div class="line"></div><div class="line">	Trie_node* pt = root;</div><div class="line">	for (int i = 0; i &lt; word.size(); ++i)</div><div class="line">	&#123;</div><div class="line">		int p = word[i] - &apos;a&apos;;</div><div class="line">		if (pt-&gt;next[p] == NULL) return 0;</div><div class="line">		if (i == nb - 1) return pt-&gt;next[p]-&gt;count;</div><div class="line">		else</div><div class="line">			pt = pt-&gt;next[p];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int Trie_main()</div><div class="line">&#123;</div><div class="line">	int N, M;</div><div class="line">	vector&lt;string&gt; words;</div><div class="line">	vector&lt;string&gt; searches;</div><div class="line"></div><div class="line">	scanf(&quot;%d&quot;, &amp;N);</div><div class="line">	getchar();</div><div class="line">	for (int i = 0; i &lt; N; ++i)</div><div class="line">	&#123;</div><div class="line">		string temp;</div><div class="line">		getline(cin, temp);</div><div class="line">		words.push_back(temp);</div><div class="line">	&#125;</div><div class="line">	scanf(&quot;%d&quot;, &amp;M);</div><div class="line">	getchar();</div><div class="line">	for (int i = 0; i &lt; M; ++i)</div><div class="line">	&#123;</div><div class="line">		string temp;</div><div class="line">		getline(cin, temp);</div><div class="line">		searches.push_back(temp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	Trie_node* root = createTrie();</div><div class="line">	for (int i = 0; i &lt; words.size(); ++i)</div><div class="line">	&#123;</div><div class="line">		insert(root, words[i]);</div><div class="line">	&#125;</div><div class="line">	for (int i = 0; i &lt; searches.size(); ++i)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;%d\n&quot;, find(root, searches[i]));</div><div class="line">	&#125;</div><div class="line">	deleteTrie(root);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计---模板/" itemprop="url">
                  C++程序设计---模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:37:26+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>. 1，文件操作<br>. 2，函数模板</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="1，数据的层次"><a href="#1，数据的层次" class="headerlink" title="1，数据的层次"></a>1，数据的层次</h3><p>位      bit<br>字节    byte<br>域/记录 如一个结构体等。<br>将所有记录<strong>顺序</strong>写入一个文件-&gt;顺序文件</p>
<p>C++标准库： ifstream ofstream fstream</p>
<h3 id="3，文件的读写指针"><a href="#3，文件的读写指针" class="headerlink" title="3，文件的读写指针"></a>3，文件的读写指针</h3><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>泛型程序设计<br>Generic Programming<br>算法实现时不指定具体要操作的数据的类型。<br><strong>泛型</strong>—算法实现一遍-&gt;适用于多种数据结构。<br>优势： 减少重复代码的编写。<br>大量编写模板，使用模板的程序设计</p>
<blockquote>
<p>. 函数模板<br>. 类模板</p>
</blockquote>
<p>函数模板<br>template <class 类型参数1，="" class类型参数2,="" ..=""><br>返回值类型 模板名（形参表）<br>{<br>    函数体<br>}</class></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计--多态和虚函数/" itemprop="url">
                  C++程序设计--多态和虚函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:52+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目的： 提高程序的可扩展性，减少增加代码时的工作量。<br>代价： 每一个有虚函数的对象都会增加四个字节的空间来存放虚函数表（空间开销）。虚函数在查虚函数表的时候会有（时间）开销。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在类的定义中，前面有<strong>virtual</strong>关键字的成员函数就是虚函数。<br>class base{<br>    <strong>virtual</strong> int get();<br>    }<br>int base::get(){};<br>virtual关键字只用在类定义里的函数声明中，写函数体时不用。<br>构造函数和静态成员函数不能是虚函数。<br>虚函数支持多态。</p>
<h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><h3 id="一，"><a href="#一，" class="headerlink" title="一，"></a>一，</h3><p>派生类的指针可以赋给基类指针。<br>通过基类指针调用基类和派生类的同名虚函数时，<br>（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；<br>（2）若指针指向一个派生类的对象，那么被调用的是派生类的虚函数。<br>这种机制就叫做“多态”。</p>
<h3 id="二，"><a href="#二，" class="headerlink" title="二，"></a>二，</h3><p>派生类的多态可以赋给基类引用。<br>通过基类引用调用基类和派生类的同名虚函数时，<br>（1）若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数；<br>（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。<br>这种机制也是“多态”。</p>
<p><strong>实际上，我们用一个基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常用的做法</strong>(例如 pshapes[100])</p>
<p>同时，在非构造函数和非析构函数的成员函数中调用虚函数，是多态！<br>而在构造函数和析构函数中调用虚函数，不是多态。这在编译时就可以确定了调用的函数是自己的类或基类中定义的函数，不会等到运行时才确定要调用哪个函数。</p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p>在运行时决定调用基类还是派生类，“动态联编”。<br>多态实现的关键—虚函数表。每一个有虚函数的类（或者有虚函数的类的派生类），都有一个虚函数表与其对应。该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的四个字节就是用来放虚函数表地址的。<br>so, 多态的调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。<br><img src="http://ww2.sinaimg.cn/mw690/a207cfd8gw1f4nwq0yglyj20ha0dkdh3.jpg" alt=""></p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>针对基类的指针删除派生类对象时 只调用基类的析构函数这种情况。<br>设计一种虚析构函数。<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8gw1f4nwq1wljej20jj0attaf.jpg" alt=""><br>类如果定义了额虚函数，则最好将析构函数也定义成虚函数。<br>当然，我们不允许构造函数是虚函数。</p>
<h2 id="纯虚函数和抽象类。"><a href="#纯虚函数和抽象类。" class="headerlink" title="纯虚函数和抽象类。"></a>纯虚函数和抽象类。</h2><p>纯虚函数： 没有函数体的虚函数。<br>抽象类 ： 包含纯虚函数的类。<br>1， 抽象类住能作为基类。<br>2， 不能创建抽象类的对象。<br>3， 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象<br><img src="http://ww4.sinaimg.cn/mw690/a207cfd8gw1f4nwq2oyqmj20na0dldij.jpg" alt=""></p>
<p>在抽象类中，<br>1，成员函数内可以调用纯虚函数/<br>2，在构造函数/析构函数内部不能调用纯虚函数。</p>
<p>如果一个类从抽象类派生而来<br>它实现了基类中所有的纯虚函数，才能成为非抽象类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计---继承和派生/" itemprop="url">
                  C++程序设计---继承和派生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:40+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继承： 在定义一个新的类B时，如果该类与某个已有的类A相似（<strong>指的是B拥有A的全部特点</strong>），那么就可以把A作为一个基类，而把B作为基类的一个派生类（也称为子类）。</p>
<h2 id="派生类："><a href="#派生类：" class="headerlink" title="派生类："></a>派生类：</h2><blockquote>
<p>派生类拥有基类的全部成员函数和成员变量，不论是private, protected还是public。<br>派生类可以对基类进行扩充，添加新的成员变量和成员函数。派生类的使用和基类无关。</p>
</blockquote>
<p>tip: 在派生类的成员函数中，不能访问继承自基类的private成员。</p>
<h3 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h3><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置位于派生类对象新增的成员变量之前。</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>派生类可以有和基类同名同参数表的函数，将会覆盖掉基类中的成员函数而不算是重复定义。比较常见的是，在派生类的覆盖函数中，先调用基类的该函数，再处理自己不同于基类中该函数的部分。</p>
<h2 id="继承关系和复合关系"><a href="#继承关系和复合关系" class="headerlink" title="继承关系和复合关系"></a>继承关系和复合关系</h2><p>继承： “<strong>是</strong>”关系。<br>基类A, B是基类A的派生类。<br>逻辑上要求：“一个B对象也是一个A对象”。</p>
<p>复合： “<strong>有</strong>”关系。<br>类C中“有”成员变量K, k是类D的对象，则C和D是复合关系。<br>一般逻辑上要求： “D对象是C对象的固有属性或者组成部分”。</p>
<p>tips:<br>1，在一个类中，如果有一个成员变量是其他类的指针，通常称为是“知道”关系。<br>2， 对于基类/派生类 同名成员，调用基类的public成员时得用 base::__ 来调用。</p>
<h2 id="访问范围说明符"><a href="#访问范围说明符" class="headerlink" title="访问范围说明符"></a>访问范围说明符</h2><p>基类的 private成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数</p>
<p>基类的 public成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数<br>    3，派生类成员函数<br>    4，派生类友员函数<br>    5，其它的函数(故用private和public并不能凸显派生类和其他类的区别，引入protected)<br>基类的 protected成员：可以被下列函数访问<br>    1，基类成员函数<br>    2，基类友员函数<br>    3，派生类的成员函数可以访问<strong>当前对象</strong>的基类的保护成员</p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类对象 包含 基类对象。<br>执行派生类构造函数前，首先必须执行<strong>基类的构造函数</strong>。<br>如果派生类中还包含成员对象，也是用参数表的形式构造。<br><img src="http://ww1.sinaimg.cn/mw690/a207cfd8jw1f4koz7s1d7j20oh0dun0j.jpg" alt=""><br>具体形式：<br>构造函数名（形参表）：基类名（基类构造函数实参表），…,成员对象（实参表）,…<br>{<br>}</p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p>class base {};<br>class derived : <strong>public</strong> base {};<br>base b; derived d;<br>在加了public后，有以下几条赋值兼容规则。<br>1，派生类的对象可以赋值给基类对象。<br> b = d;（把d里面包含的base对象 赋值到b里去）<br>2，派生类对象可以初始化基类引用。<br> base&amp; br = d;<br>3， 派生类对象的地址可以赋值给基类的指针<br> base* pb = &d;</p>
<p> tips : 声明派生类时，只需要列出它直接基类，构造时也只考虑直接基类的参数表。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/C++程序设计--运算符重载/" itemprop="url">
                  C++程序设计--运算符重载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T19:36:30+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p>1， 运算符重载<br>2， 赋值运算符的重载<br>3， 流插入运算符重载<br>4，自加/自减运算符的重载</p>
</blockquote>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>作用：对抽象数据类型也能够直接使用C++提供的运算符。<br>使得程序更简洁。<br>代码更容易理解。</p>
<p><strong>运算符重载的实质是函数重载</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">返回值类型 operator运算符 （形参表）</div><div class="line">&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">class Complex</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Complex(double r = 0.0, double i = 0.0);</div><div class="line">	</div><div class="line"></div><div class="line">	Complex operator+(const Complex c1);</div><div class="line">	Complex operator-(const Complex c1);</div><div class="line"></div><div class="line">	double real;</div><div class="line">	double imag;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Complex::Complex(double r, double i)</div><div class="line">&#123;</div><div class="line">	real = r;</div><div class="line">	imag = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Complex Complex::operator+(const Complex c1)</div><div class="line">&#123;</div><div class="line">	return Complex(real + c1.real, imag + c1.imag);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Complex Complex::operator-(const Complex c1)</div><div class="line">&#123;</div><div class="line">	return Complex(this-&gt;real - c1.real, this-&gt;imag - c1.imag);</div><div class="line">&#125;</div><div class="line">//普通类型的运算符重载</div><div class="line">Complex operator+ (const Complex c1, const Complex c2)</div><div class="line">&#123;</div><div class="line">	return Complex(c1.real + c2.real, c1.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运算符可以重载成普通函数，也能重载为成员函数。前者的参数个数就是对应操作符的目数，而成员函数则是目数减一。</p>
<h3 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h3><p>1，赋值运算符两边的类型可以不匹配。<br>如：将一个Int类型的变量赋值给一个Complex对象。<br>2，对一个自己写的类想要进行 = 赋值时，需要重载赋值运算符”=”<br>3，赋值运算符“=”只能重载为<strong>成员函数</strong><br><strong>一般来说，赋值运算符的重载的返回值是该对象本身的引用，来满足=的意义。</strong></p>
<h3 id="流插入运算符重载"><a href="#流插入运算符重载" class="headerlink" title="流插入运算符重载"></a>流插入运算符重载</h3><p>cout本身就是ostream的一个对象，而cout&lt;&lt;其实是在ostream类中对&lt;&lt;进行了重载。<br>我们如果想通过&lt;&lt; &gt;&gt;来实现自己对应的对象的输入和输出，则可以自己来重载这两个运算符。<br>一般定义为全局函数，因为iostream类C++已经写好了。<br>比如实现对复数类的输入输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, Complex&amp; c)</div><div class="line">&#123;</div><div class="line">	o &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">istream&amp; operator&gt;&gt;(istream&amp; i, Complex&amp; c)</div><div class="line">&#123;</div><div class="line">	//先读进string里面再分别剥离出real imag</div><div class="line">	return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自加-自减运算符的重载"><a href="#自加-自减运算符的重载" class="headerlink" title="自加/自减运算符的重载"></a>自加/自减运算符的重载</h3><p>前置和后置有区别，<br>前置是一元运算符，后置是二元运算符。多出来的一个参数具体是啥无意义，只是为了标记这是一个后置运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class CDemo</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	CDemo(int _n) :n(_n)&#123;&#125;;</div><div class="line"></div><div class="line">	CDemo operator++();</div><div class="line">	CDemo operator++(int);</div><div class="line"></div><div class="line">	//强制类型转化</div><div class="line">	operator int()&#123; return n; &#125;</div><div class="line">	</div><div class="line">	friend CDemo operator--(CDemo&amp;);</div><div class="line">	friend CDemo operator--(CDemo&amp;, int);</div><div class="line">private:</div><div class="line">	int n;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//前置</div><div class="line">CDemo CDemo::operator++()</div><div class="line">&#123;</div><div class="line">	n++;</div><div class="line">	return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CDemo operator--(CDemo&amp; d)</div><div class="line">&#123;</div><div class="line">	d.n--;</div><div class="line">	return d;</div><div class="line">&#125;</div><div class="line">//后置</div><div class="line">CDemo CDemo::operator++(int)</div><div class="line">&#123;</div><div class="line">	CDemo temp (*this);</div><div class="line">	n++;</div><div class="line">	return temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CDemo operator--(CDemo&amp; d, int)</div><div class="line">&#123;</div><div class="line">	CDemo t = d;</div><div class="line">	d.n--;</div><div class="line">	return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：上面的demo中int作为一个类型强制转换运算符被重载，Demo s; (int)s等效于s.int()。<br>类型强制转换运算符被重载时，不能写返回值类型，实际上其返回值就是类型转换所代表的类型。</p>
<p>Tips:<br>1，C++不允许定义新的运算符。<br>2，重载后的运算符应该符合日常习惯。<br>3，重载运算符不能改变运算符的优先级。<br>4，以下运算符不能被重载。”.” “*” “::” “?”,sizeof<br>5，重载运算符(), [], -&gt;或者赋值运算符时，只能被声明为类的成员函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/13774767?v=3&s=466"
               alt="Storm han" />
          <p class="site-author-name" itemprop="name">Storm han</p>
          <p class="site-description motion-element" itemprop="description">拿梦想做赌注，我怎么舍得输？</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/stormHan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/han-jia-wei" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Storm han</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
