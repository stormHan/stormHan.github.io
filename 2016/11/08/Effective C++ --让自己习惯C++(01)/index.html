<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Effective C++ --让自己习惯C++(01) | Han&#39;s Blog Cell</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一，View C++ as a federation of languages.(01)主要内容将C++视为一个由相关语言组成的语言联邦。在某个次语言(sublanguage)中，各种守则与通例都倾向于简单，直观。然而当从一个次语言转移到另一个次语言中时，守则可能改变。而其主要的次语言总共有四个：


1，C语言。C++以C为基础，很多的概念来源于C，blocks, statements, pre">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ --让自己习惯C++(01)">
<meta property="og:url" content="http://yoursite.com/2016/11/08/Effective C++ --让自己习惯C++(01)/index.html">
<meta property="og:site_name" content="Han's Blog Cell">
<meta property="og:description" content="一，View C++ as a federation of languages.(01)主要内容将C++视为一个由相关语言组成的语言联邦。在某个次语言(sublanguage)中，各种守则与通例都倾向于简单，直观。然而当从一个次语言转移到另一个次语言中时，守则可能改变。而其主要的次语言总共有四个：


1，C语言。C++以C为基础，很多的概念来源于C，blocks, statements, pre">
<meta property="og:updated_time" content="2016-11-09T13:38:18.539Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective C++ --让自己习惯C++(01)">
<meta name="twitter:description" content="一，View C++ as a federation of languages.(01)主要内容将C++视为一个由相关语言组成的语言联邦。在某个次语言(sublanguage)中，各种守则与通例都倾向于简单，直观。然而当从一个次语言转移到另一个次语言中时，守则可能改变。而其主要的次语言总共有四个：


1，C语言。C++以C为基础，很多的概念来源于C，blocks, statements, pre">
  
    <link rel="alternate" href="/atom.xml" title="Han&#39;s Blog Cell" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Han&#39;s Blog Cell</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hi, My world!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Effective C++ --让自己习惯C++(01)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/08/Effective C++ --让自己习惯C++(01)/" class="article-date">
  <time datetime="2016-11-08T03:02:34.594Z" itemprop="datePublished">2016-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective C++ --让自己习惯C++(01)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一，View-C-as-a-federation-of-languages-01"><a href="#一，View-C-as-a-federation-of-languages-01" class="headerlink" title="一，View C++ as a federation of languages.(01)"></a>一，View C++ as a federation of languages.(01)</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>将C++视为一个由相关语言组成的语言联邦。<br>在某个次语言(sublanguage)中，各种守则与通例都倾向于简单，直观。然而当从一个次语言转移到另一个次语言中时，守则可能改变。而其主要的次语言总共有四个：</p>
<blockquote>
<blockquote>
<p>1，C语言。C++以C为基础，很多的概念来源于C，blocks, statements, preprocessor, built-in data types, arrays, pointers。但C也有其局限性：没有模板（templates），没有异常（exceptions），没有重载（overloading）</p>
<p>2，Object-Oriented C++。这一部分是面向对象设计古典守则在C++上最直接的实施。也是C with classes所诉求的：classes（包括构造函数，析构函数），封装（encapsulation），继承（inheritance），多态（polymorphism），virtual函数（动态绑定）。</p>
<p>3，Template C++。C++的泛型编程，也是大多数程序员经验最少的部分。Template相关考虑与设计已经弥漫整个C++，良好编程守则中“唯template”适用的特殊条款并不罕见。</p>
<p>4，STL。一个template程序库，对容器（containers），迭代器（iterators），算法（algorithms）已经函数对象的规约有极佳的紧密配合与协调。</p>
</blockquote>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住这四个次语言，当你从某个次语言切换到另一个，导致高效变成守则要求你改变策略时，不要感到惊讶。例如对内置类型而言pass-by-value通常比pass-by-reference高效，但当你从C part of C++移往Object-Oriented-C++时，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，运用TemplateC++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数都是在C指针之上塑造的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则再次适用。</p>
<p>因此C++是四个次语言组成的语言联邦政府，每个语言都有自己的规约。记住这四个次语言你就会发现C++容易理解很多。</p>
<h1 id="Prefer-consts-enums-and-inlines-to-defines-02"><a href="#Prefer-consts-enums-and-inlines-to-defines-02" class="headerlink" title="Prefer consts, enums, and inlines to #defines.(02)"></a>Prefer consts, enums, and inlines to #defines.(02)</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><p><strong>尽量减少#define的使用，多让编译器去工作而不是让预处理器工作！！</strong><br>原因一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define RATIO 1.635</div><div class="line">//也许从未被编译器看见而被预处理器拿走从而会报错。</div><div class="line"></div><div class="line">const double Ratio = 1.635；//这样则不会出问题</div></pre></td></tr></table></figure>
<p> 在声明常量（通常放在头文件里）的时候需要注意两个问题<br> 1， 常量字符串<br> const char* const authorNmae = “Scott Meyers”<br> 2，类常量，不需要每个对象都有自己的常量，故为静态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class GamePlayer&#123;</div><div class="line"> private:</div><div class="line">    static const int Number = 5;</div><div class="line">    int scores[Number];</div><div class="line">    ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意，这里的number只是声明式，（相当于函数只声明了还没实现）。如果需要取这个常量的地址，则需要在实现文件里写它的定义式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const int GamePlayer::Number; //Number 的定义，此时不需要再赋值</div></pre></td></tr></table></figure></p>
<p>原因二：</p>
<p> #define是不重视域的。这意味着#define不仅不能够用来定义class的专属常量，而且不能提供任何的封装性。</p>
<p> 原因三：<br> 不推荐使用预处理器来实现宏（macros）。宏看起来很像函数，其优点是不会招致函数调用的额外开销。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define CALL_WITH_MAX(a, b) f((a)&gt;(b) &gt; (a) : (b))</div></pre></td></tr></table></figure></p>
<p><strong>这种宏是有很多缺点的！</strong><br>首先，再你写出这种宏的时候，你必须要为每一个实参加上小括号！否则某人在<strong>表达式</strong>中调用这个宏就会遭遇麻烦。但纵然如此，也不可避免会出现麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a = 5;</div><div class="line">int b = 0;</div><div class="line"></div><div class="line">   CALL_WITH_MAX(++a, b);        //a = 7 </div><div class="line">CALL_WITH_MAX(++a, b + 10);   //a = 6</div></pre></td></tr></table></figure></p>
<p>结果甚至会因为比较的值不同而不同，相当于程序错误。（其原因是参数被核算多次）。<br>而推荐使用的是template inline函数，既可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">inline void callWithMax(const T&amp; a, const T&amp; b)</div><div class="line">&#123;</div><div class="line">    f(a &gt; b ? a : b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了consts, enums和inlines，我们对于预处理器（特别是#define）的需求降低了，但并非完全消除。#include依然是必需品，而#ifdef / #ifndef也继续扮演着控制编译的重要角色。目前还不到预处理全面而退的时候，但你应该明确地给予它更长更频繁的假期！</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>对于单纯常量，最好以const对象或者enum替换#define。</strong><br><strong>对于形似函数的宏，最好改用inline函数替代#define。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/08/Effective C++ --让自己习惯C++(01)/" data-id="civndnf5l0006sgwa74gir3x3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/09/Effective C++ --让自己习惯C++(02)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Effective C++ --让自己习惯C++(02)
        
      </div>
    </a>
  
  
    <a href="/2016/11/08/Trie树/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Trie树</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/09/Effective C++ --让自己习惯C++(02)/">Effective C++ --让自己习惯C++(02)</a>
          </li>
        
          <li>
            <a href="/2016/11/08/Effective C++ --让自己习惯C++(01)/">Effective C++ --让自己习惯C++(01)</a>
          </li>
        
          <li>
            <a href="/2016/11/08/Trie树/">Trie树</a>
          </li>
        
          <li>
            <a href="/2016/11/04/C++程序设计---模板/">C++程序设计---模板</a>
          </li>
        
          <li>
            <a href="/2016/11/04/C++程序设计--多态和虚函数/">C++程序设计--多态和虚函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Storm han<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>